1:"$Sreact.fragment"
2:I[2034,["173","static/chunks/173-7be02dd55462ff0c.js","678","static/chunks/678-9555f6ed956a8d40.js","177","static/chunks/app/layout-ebf74d6892f2c1b6.js"],"SidebarProvider"]
3:I[1543,["173","static/chunks/173-7be02dd55462ff0c.js","678","static/chunks/678-9555f6ed956a8d40.js","177","static/chunks/app/layout-ebf74d6892f2c1b6.js"],"AppSidebar"]
4:I[2034,["173","static/chunks/173-7be02dd55462ff0c.js","678","static/chunks/678-9555f6ed956a8d40.js","177","static/chunks/app/layout-ebf74d6892f2c1b6.js"],"SidebarTrigger"]
5:I[5244,[],""]
6:I[3866,[],""]
8:I[6213,[],"OutletBoundary"]
a:I[6213,[],"MetadataBoundary"]
c:I[6213,[],"ViewportBoundary"]
e:I[4835,[],""]
:HL["/cmput412-akhadeli/_next/static/media/a34f9d1faa5f3315-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/cmput412-akhadeli/_next/static/css/f8c155f11af27ff1.css","style"]
:HL["/cmput412-akhadeli/_next/static/css/e23141aac3fba32d.css","style"]
7:T456,prose prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white prose-md prose-p:text-lg prose-p:leading-relaxed prose-p:text-gray-800 dark:prose-p:text-gray-100 prose-table:w-full prose-table:border-collapse prose-table:border-gray-300 prose-table:dark:border-gray-600 prose-table:text-left prose-table:text-sm prose-table:text-gray-800 dark:prose-table:text-gray-100 prose-ul:text-gray-800 dark:prose-ul:text-gray-100 prose-li:text-gray-800 dark:prose-li:text-gray-100 prose-strong:text-gray-800 prose-strong:font-bold dark:prose-strong:text-gray-100 prose-img:w-full prose-img:rounded-lg prose-img:border prose-img:border-border prose-img:dark:border-border prose-video:w-full prose-video:rounded-lg prose-video:border prose-video:border-border prose-video:dark:border-border prose-iframe:w-full prose-iframe:rounded-lg prose-iframe:border prose-iframe:border-border prose-iframe:dark:border-border prose-span:text-gray-800 prose-span:dark:text-gray-1000:{"P":null,"b":"IyTIDrFCTj8nxwzP0krqc","p":"/cmput412-akhadeli","c":["","exercises","ex3"],"i":false,"f":[[["",{"children":["exercises",{"children":["ex3",{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/cmput412-akhadeli/_next/static/css/f8c155f11af27ff1.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":["$","body",null,{"className":"__className_23f766 antialiased","children":["$","$L2",null,{"children":[["$","$L3",null,{}],["$","$L4",null,{"className":"ml-3 mt-3"}],["$","main",null,{"className":"flex-1 overflow-auto p-8 pt-16","children":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]]}]}]}]]}],{"children":["exercises",["$","$1","c",{"children":[null,["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","exercises","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["ex3",["$","$1","c",{"children":[null,["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","exercises","children","ex3","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":[["$","main",null,{"className":"mx-auto max-w-3xl","children":["$","div",null,{"className":"$7","children":[["$","h1",null,{"children":"CMPUT 412/503 - Exercise 3 Report"}],"\n",["$","h2",null,{"children":"Abdullah Khadeli and Ryan Rom"}],"\n",["$","h3",null,{"children":"Part I - Computer Vision"}],"\n",["$","h4",null,{"children":"Camera distortion"}],"\n",["$","p",null,{"children":["Distorted image from the Duckiebot camera\n",["$","img",null,{"src":"/cmput412-akhadeli/images/ex3/distorted.png","alt":"Calibration board (distorted)"}]]}],"\n",["$","hr",null,{}],"\n",["$","p",null,{"children":["Undistorted image from the Duckiebot camera\n",["$","img",null,{"src":"/cmput412-akhadeli/images/ex3/undistorted.png","alt":"Calibration board (undistorted)"}]]}],"\n",["$","p",null,{"children":"In the first image, we can see that the calibration board is distorted due to radial and tangential distortion from the camera lens. In the second image, we can see that the lines appear straight as they should be in reality."}],"\n",["$","p",null,{"children":"(The sheet with the board was slightly bent, which is why the lines are not perfectly straight in the undistorted image, however the table pattern is shown to be straight, showing that the undistortion is working)"}],"\n",["$","p",null,{"children":"Frames from the Duckiebot camera are distorted due to lens imperfections. Converting distorted images to undistorted ones requires using the camera's intrinsic parameters:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"Subscribing to the camera topic to get the distorted image"}],"\n",["$","li",null,{"children":"Obtaining camera intrinsic parameters (focal length, optical center, distortion coefficients) from the ROS topic for camera intrinsics"}],"\n",["$","li",null,{"children":"Using OpenCV's undistort function with the obtained parameters"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"undistorted_image = cv2.undistort(distorted_image, camera_matrix, dist_coeffs)\n"}]}],"\n",["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"Publishing the undistorted image to a new topic"}],"\n"]}],"\n",["$","h4",null,{"children":"Color detection"}],"\n",["$","p",null,{"children":["Image from rqt_image_view showing blue contours\n",["$","img",null,{"src":"/cmput412-akhadeli/images/ex3/blue.png","alt":"rqt_image_view (blue contours)"}]]}],"\n",["$","hr",null,{}],"\n",["$","p",null,{"children":["Image from rqt_image_view showing red contours\n",["$","img",null,{"src":"/cmput412-akhadeli/images/ex3/red.png","alt":"rqt_image_view (red contours)"}]]}],"\n",["$","hr",null,{}],"\n",["$","p",null,{"children":["Image from rqt_image_view showing green contours\n",["$","img",null,{"src":"/cmput412-akhadeli/images/ex3/green.png","alt":"rqt_image_view (green contours)"}]]}],"\n",["$","p",null,{"children":"These images demonstrate our color detection algorithm in action. We're using contour detection to identify colored lines in the environment:"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"The blue bounding box in the image shows detection of blue tape on the ground"}],"\n",["$","li",null,{"children":"The red bounding box in the image shows detection of red tape on the ground"}],"\n",["$","li",null,{"children":"The green bounding box in the image shows detection of green tape on the ground"}],"\n"]}],"\n",["$","p",null,{"children":"In each case, we've used the contours to draw a bounding rectangle around the detected colored area and labeled it with the color name. This visualization helps us verify the accuracy of our HSV range selection and determine the position and dimensions of the line in the robot's camera plane."}],"\n",["$","h3",null,{"children":"Color Detection Methodology"}],"\n",["$","p",null,{"children":"Color detection works by filtering pixels in the HSV (Hue, Saturation, Value) color space, which separates color information from lighting conditions in a more understandable way compared to RGB. Our approach:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"Convert the camera image from RGB to HSV color space using"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n"}]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":["Define HSV range thresholds for each color:","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Red: Lower [0, 100, 100], Upper [10, 255, 255]"}],"\n",["$","li",null,{"children":"Blue: Lower [100, 150, 0], Upper [140, 255, 255]"}],"\n",["$","li",null,{"children":"Green: Lower [40, 40, 150], Upper [90, 255, 255]"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":"Create binary masks that isolate pixels within those thresholds using:"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"cv2.inRange(image, lower_bound, upper_bound)\n"}]}],"\n",["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"Apply dilation with a 5x5 kernel to improve connectivity of detected regions"}],"\n",["$","li",null,{"children":"Find contours in the binary mask with RETR_TREE and CHAIN_APPROX_SIMPLE as per the GeeksForGeeks Article using:"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"cv2.findContours()\n"}]}],"\n",["$","ol",null,{"start":"6","children":["\n",["$","li",null,{"children":"Filter contours by area (must be > 300 pixels) to eliminate small noise and artifacts"}],"\n",["$","li",null,{"children":"Draw bounding rectangles around valid contours and add relevant text labels"}],"\n"]}],"\n",["$","p",null,{"children":"Tuning HSV parameters required an iterative process:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"Starting with initial estimates based on standard HSV color ranges"}],"\n",["$","li",null,{"children":"Testing with images captured in the lab environment"}],"\n",["$","li",null,{"children":"Adjusting ranges incrementally to improve detection under existing lighting conditions"}],"\n",["$","li",null,{"children":"Finding thresholds that balance detection sensitivity with resistance to noise"}],"\n"]}],"\n",["$","p",null,{"children":"Challenges faced:"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["Finding the right HSV values for all colors due to the variability in reflected light on the tape.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"We had to use broader ranges for detection to account for this variability, which occasionally resulted in false positives that we usually filtered out using the area threshold."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":"Shadows on the tape also affected detection, as they were picked up as a different color, so we had to account for that when tuning the HSV values."}],"\n"]}],"\n",["$","h3",null,{"children":"Color-Based Behavioral Execution and Line Detection"}],"\n",["$","p",null,{"children":"Video showing the robot's behavior when encountering a blue line"}],"\n",["$","video",null,{"src":"/cmput412-akhadeli/images/ex3/blue_behavior.mp4","controls":true}],"\n",["$","hr",null,{}],"\n",["$","p",null,{"children":"Video showing the robot's behavior when encountering a red line"}],"\n",["$","video",null,{"src":"/cmput412-akhadeli/images/ex3/red_behavior.mp4","controls":true}],"\n",["$","hr",null,{}],"\n",["$","p",null,{"children":"Video showing the robot's behavior when encountering a green line"}],"\n",["$","video",null,{"src":"/cmput412-akhadeli/images/ex3/green_behavior.mp4","controls":true}],"\n",["$","p",null,{"children":"These videos demonstrate our robot's behavior when encountering different colored lines:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Blue Line Behavior"}],": When the robot detects a blue line, it stops for 5 seconds, signals the right-side LEDs (both front and back), and then makes a right turn."]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Red Line Behavior"}],": Upon detecting a red line, the robot stops for 5 seconds and then moves straight forward for 60cm."]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Green Line Behavior"}],": When the robot encounters a green line, it stops for 5 seconds, signals the left-side LEDs (both front and back), and then makes a left turn."]}],"\n"]}],"\n"]}],"\n",["$","p",null,{"children":"For implementing these behaviors, we:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"Used a pixel-counting approach to determine which color has the highest count in the frame:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"detected_color_index = np.argmax([self.blue_count, self.red_count, self.green_count])\n"}]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"Used a homography-based distance estimation to determine how far the robot is from the detected line:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"def get_distance_from_line(self, colorIndex):\n    # Transform image coordinates to real-world coordinates using homography\n    homography_matrix, _ = cv2.findHomography(src, dst)\n    center = self.get_object_center_from_mask(mask)\n    transformed_point = cv2.perspectiveTransform(point_in_image, homography_matrix)\n    return transformed_point[0][0][1]  # Returns distance in meters\n"}]}],"\n"]}],"\n"]}],"\n",["$","p",null,{"children":"To detect lines and determine lane dimensions, we implemented the following approach:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Line Detection"}],": After creating color masks as described earlier, we use contour detection to identify regions of the detected color."]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Lane Dimension Determination"}],":"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["Extract the bounding rectangle of each contour using","\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"cv2.boundingRect()\n"}]}],"\n"]}],"\n",["$","li",null,{"children":"Calculate the width, height, and centroid of each rectangle in the frame"}],"\n",["$","li",null,{"children":"Therefore, in relative terms, we can determine if we're approaching the line and how far we are from it"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","h3",null,{"children":"Integration"}],"\n",["$","p",null,{"children":"Our integration of the computer vision, LED control, and wheel movement nodes is as follows:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Node Architecture"}],":"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["Our ",["$","em",null,{"children":"ColorDetection"}]," node processes images and publishes color masks to the relevant ROS topics."]}],"\n",["$","li",null,{"children":["The ",["$","em",null,{"children":"BehavioralExecution"}]," node or any other executing node subscribes to these color masks and controls robot behavior, and executes its programmed behavior based on the color detected. Additionally, this node will publish LED instructions and wheel commands to the relevant ROS topics."]}],"\n",["$","li",null,{"children":["A wheel control system subscribes to the wheel encoder topic and handles precise movement based on wheel encoder feedback, for example the ",["$","em",null,{"children":"PIDController"}]," node."]}],"\n",["$","li",null,{"children":"An LED controller activates LEDs according to instructions obtained from the topic controlling the LEDs."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Integration Improvements"}],":"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"We implemented a sequential task-based architecture where each movement behavior is encapsulated in a task class"}],"\n",["$","li",null,{"children":["To improve our system we could:","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Use a state based architecture, creating room for RL based approaches (beyond the scope of the exercises)"}],"\n",["$","li",null,{"children":"Allow for parallel execution of tasks"}],"\n"]}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Optimization and Delay Handling"}],":"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Implement a queue system on top of our task based architecture to handle delays more gracefully"}],"\n",["$","li",null,{"children":"Add default behavior for the robot in case of network loss or delay"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Camera Frequency and Update Rate Impact"}],":"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"Having a higher camera frequency and control update rate would allow for more precise control of the robot, as we would have more data to work with."}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"However, this would require more compute, which could cause delays and potentially cause the robot to lose control."}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Especially with the camera frames, since we do some image processing in the node."}],"\n",["$","li",null,{"children":"We would downscale the image to a lower resolution to reduce processing time, but this would reduce the accuracy of the color detection."}],"\n"]}],"\n"]}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","h3",null,{"children":"Part II - Controllers"}],"\n",["$","p",null,{"children":"Video showing the robot following a straight lane using a P controller"}],"\n",["$","video",null,{"src":"/cmput412-akhadeli/images/ex3/P_Controller.mp4","controls":true}],"\n",["$","hr",null,{}],"\n",["$","p",null,{"children":"Video showing the robot following a straight lane using a PD controller"}],"\n",["$","video",null,{"src":"/cmput412-akhadeli/images/ex3/PD_Controller.mp4","controls":true}],"\n",["$","hr",null,{}],"\n",["$","p",null,{"children":"Video showing the robot following a straight lane using a PID controller"}],"\n",["$","video",null,{"src":"/cmput412-akhadeli/images/ex3/PID_Controller.mp4","controls":true}],"\n",["$","p",null,{"children":"Each video shows the robot following a straight lane for at least 1.5 meters, demonstrating the performance characteristics of each controller type:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":[["$","strong",null,{"children":"P Controller"}],": The robot uses a simple proportional controller that adjusts turning based on the error between its current position and the desired lane position."]}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"In the video we can see slight oscillations, but the robot is able to follow the lane."}],"\n"]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":[["$","strong",null,{"children":"PD Controller"}],": Building on the P controller, this adds a derivative term that considers how quickly the error is changing, helping to reduce oscillation."]}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"In the video we can see a strong correction initially, and then smoother corrections for the oscillations."}],"\n"]}],"\n",["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":[["$","strong",null,{"children":"PID Controller"}],": The most complex controller, adding an integral term to the PD controller to address systematic biases and reduce steady-state error."]}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"In the video we can see a good balance between responsiveness and stability, with very minimal oscillations."}],"\n"]}],"\n",["$","h3",null,{"children":"Controller Analysis"}],"\n",["$","h4",null,{"children":"Pros and Cons of Different Controllers"}],"\n",["$","p",null,{"children":[["$","strong",null,{"children":"P (Proportional) Controller"}],":"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":[["$","strong",null,{"children":"Pros"}],":","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Simple to implement"}],"\n",["$","li",null,{"children":"Computationally efficient"}],"\n",["$","li",null,{"children":"Intuitive tuning"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":[["$","strong",null,{"children":"Cons"}],":","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Prone to oscillation"}],"\n",["$","li",null,{"children":"Struggles with quick response to large errors"}],"\n",["$","li",null,{"children":"May have steady-state error"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","p",null,{"children":[["$","strong",null,{"children":"PD (Proportional-Derivative) Controller"}],":"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":[["$","strong",null,{"children":"Pros"}],":","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Reduces oscillation"}],"\n",["$","li",null,{"children":"Faster response to changing errors"}],"\n",["$","li",null,{"children":"More stable than P controller"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":[["$","strong",null,{"children":"Cons"}],":","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"More complex tuning"}],"\n",["$","li",null,{"children":"Sensitive to noise"}],"\n",["$","li",null,{"children":"Still may have steady-state error"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","p",null,{"children":[["$","strong",null,{"children":"PID (Proportional-Integral-Derivative) Controller"}],":"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":[["$","strong",null,{"children":"Pros"}],":","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Eliminates steady-state error"}],"\n",["$","li",null,{"children":"Handles external disturbances well"}],"\n",["$","li",null,{"children":"Most robust of the three"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":[["$","strong",null,{"children":"Cons"}],":","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Most complex to tune"}],"\n",["$","li",null,{"children":"Can introduce instability if tuned incorrectly"}],"\n",["$","li",null,{"children":"Highest compute requirements"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","h4",null,{"children":"Error Calculation"}],"\n",["$","p",null,{"children":"Our error calculation is based on perspective-transformed lane detection:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"We do a perspective transformation to convert the camera view to a bird's-eye view:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"src = np.float32([\n    [0,382],\n    [224, 191],  # Bottom left (near where left lane line is)\n    [589, 382],  # Bottom right (near where right lane line is)\n    [364, 191],  # Top left (near vanishing point for left lane)\n])\n\ndst = np.float32([\n    [100, 382],\n    [100, 0],    # Bottom left (destination for left lane)\n    [489, 382],  # Bottom right (destination for right lane)\n    [489, 0],    # Top left (destination after warping)\n])\n\nM = cv2.getPerspectiveTransform(src, dst)\nwarped = cv2.warpPerspective(image, M, img_size)\n"}]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"We detect both yellow and white lane lines using HSV color filtering:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"# White lane detection\nlower_white = np.array([0, 0, 200], dtype=np.uint8)\nupper_white = np.array([180, 50, 255], dtype=np.uint8)\nmask_white = cv2.inRange(hsv, lower_white, upper_white)\n\n# Yellow lane detection\nlower_yellow = np.array([15, 100, 100], dtype=np.uint8)\nupper_yellow = np.array([35, 255, 255], dtype=np.uint8)\nmask_yellow = cv2.inRange(hsv, lower_yellow, upper_yellow)\n"}]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"We compute error as the sum of errors between detected lane pixels and their target positions:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"# The error is the sum of yellow lane errors and white lane errors\nerror = compute_error(mask=mask_yellow, target_x=100) + compute_error(mask=mask_white, target_x=489)\n"}]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"In the error computation, we find all non-zero pixels in each mask and calculate their distance from the target position:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"# Find nonzero (active) pixel coordinates\ny_coords, x_coords = np.where(mask > 0)\n\nif len(x_coords) == 0:\n   return 0  # No detected yellow pixels, return 0 error\n\n# Compute the error as the difference from target_x\nerrors = (x_coords - target_x) * pixel_value\n\n# Return the sum of the errors\nreturn np.sum(errors)\n"}]}],"\n"]}],"\n"]}],"\n",["$","h4",null,{"children":"PID Controller Implementation"}],"\n",["$","p",null,{"children":"Using the error calculated above, the controller adjusts the wheel speeds:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Proportional Term"}],": Directly proportional to the current error"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"P = self._error * self.proportional_gain\n"}]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Derivative Term"}],": Based on the rate of change of error"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"errorRateOfChange = self._error - self._error_last\nD = self.derivate_gain * errorRateOfChange\n"}]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Integral Term"}],": Based on accumulated error over time, with saturation to prevent integral windup"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"integration_stored_update = self._integration_stored + (self._error)\nself._integration_stored = (integration_stored_update) if abs(integration_stored_update) <= self.integral_saturation else (integration_stored_update/integration_stored_update)*self.integral_saturation\nI = self.integral_gain * self._integration_stored\n"}]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Final Control Signal"}],": The sum of all three terms"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"correction = P + I + D\n"}]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Correction Update"}],": We apply the correction by adjusting wheel speeds depending on the direction:"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-python","children":"if correctionUpdate < 0:\n    message = WheelsCmdStamped(vel_left=self.vel, vel_right=self.vel+abs(correctionUpdate))\nelif correctionUpdate > 0:\n    message = WheelsCmdStamped(vel_left=self.vel+abs(correctionUpdate), vel_right=self.vel)\nelse:\n    message = WheelsCmdStamped(vel_left=self.vel, vel_right=self.vel)\n"}]}],"\n"]}],"\n"]}],"\n",["$","h4",null,{"children":"Impact of Derivative Term"}],"\n",["$","p",null,{"children":"The derivative term in our PD controller significantly improved performance by:"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Reducing oscillations by dampening the control response."}],"\n",["$","li",null,{"children":"Anticipating the error and correcting for it."}],"\n",["$","li",null,{"children":"Smoothing transitions between straight sections and curves."}],"\n",["$","li",null,{"children":"Preventing overshooting when correcting large position errors."}],"\n"]}],"\n",["$","p",null,{"children":"We found the derivative term particularly beneficial when the robot needed to make gradual corrections rather than sharp movements, which helped maintain smoother trajectories."}],"\n",["$","h4",null,{"children":"Impact of Integral Term"}],"\n",["$","p",null,{"children":"The integral term in our PID controller provided several benefits:"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Eliminated persistent offset errors that remained with just P and D terms."}],"\n",["$","li",null,{"children":"Accounted for biases (drift) in our robot's movement, such as slight wheel calibration differences."}],"\n",["$","li",null,{"children":"Improved performance on longer straight sections by gradually correcting small deviations."}],"\n",["$","li",null,{"children":"Added robustness against uneven surfaces."}],"\n"]}],"\n",["$","p",null,{"children":"We implemented integral saturation to prevent the integral term from becoming too large (integral windup), which could cause overcorrection and instability."}],"\n",["$","h4",null,{"children":"Controller Tuning"}],"\n",["$","p",null,{"children":"Through systematic testing, we tuned our PID controller parameters:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Tuning Process"}],":"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"We first tuned the proportional gain until the robot could roughly follow the lane."}],"\n",["$","li",null,{"children":"Then added derivative gain to reduce oscillations."}],"\n",["$","li",null,{"children":"Finally added integral gain to eliminate steady-state error."}],"\n",["$","li",null,{"children":"We used a large integral saturation value to allow for significant error accumulation while preventing extreme integral windup, preventing overshooting."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Performance Adjustments"}],":"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Increased base velocity required higher gains for stable control over uneven surfaces."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Final Parameters"}],": We arrived at the following values:"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Proportional gain: 0.0000002"}],"\n",["$","li",null,{"children":"Derivative gain: 0.0000002"}],"\n",["$","li",null,{"children":"Integral gain: 0.0000002"}],"\n",["$","li",null,{"children":"Base velocity: 0.3"}],"\n",["$","li",null,{"children":"Integral saturation: 500000"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","p",null,{"children":"We found a good balance between responsiveness and stability, allowing the robot to maintain lane position through straight sections and curves with these parameters."}],"\n",["$","h3",null,{"children":"Part III - Lane following"}],"\n",["$","video",null,{"src":"/cmput412-akhadeli/images/ex3/Best_Lane_Following.mp4","controls":true}],"\n",["$","p",null,{"children":"This video demonstrates our robot performing lane following for a few complete laps around the track using our PID controller. We find this demostration to be a great success, as the robot is able to follow the lane consistently, and is able to navigate the track without veering off the lane."}],"\n",["$","p",null,{"children":"As we can see in the first curve in the video, the robot did slightly oversteer, but was able to correct itself and stay in the lane. This is a good demonstration of the robot's ability to navigate tight curves where we believe the lane lines might partially leave the camera view."}],"\n",["$","h4",null,{"children":"Lane following - P (Proportional) Controller"}],"\n",["$","p",null,{"children":"Our basic proportional controller began with a gain of 0.0000002 and a base velocity of 0.3. With just the P controller, the robot could follow the lane but exhibited noticeable oscillation, especially after the turns, where the robot would slightly overshoot the lane."}],"\n",["$","p",null,{"children":"When encountering large errors (such as when the robot deviates significantly from the center), the P controller would often overshoot, leading to a oscillating \"wobbling\" behavior. The correction was directly proportional to the error, which meant that larger errors caused more aggressive corrections that often led to overshooting, which created a cycle where the robot would continually overcorrect, making it difficult to stabilize in the lane center."}],"\n",["$","h4",null,{"children":"Lane following - PD (Proportional-Derivative) Controller"}],"\n",["$","p",null,{"children":"Adding the derivative term to create a PD controller significantly improved stability. With a derivative gain of 0.0000002, the D term helped dampen the oscillations by considering how quickly the error was changing:"}],"\n",["$","p",null,{"children":"Corrections were smoother and reduced overshooting when dealing with larger errors, such as when recovering from a sharp turn. This approach was particularly effective when transitioning from straight sections to turns, where error values change rapidly."}],"\n",["$","h4",null,{"children":"Lane following - PID (Proportional-Integral-Derivative) Controller"}],"\n",["$","p",null,{"children":"With an integral gain of 0.0000002, the I term helped address biases in our robot's build, such as slight weight imbalances or wheel calibration differences causing drifiting:"}],"\n",["$","p",null,{"children":"This eliminated the small but persistent offset from the lane center that the PD controller couldn't fully resolve after correcting for the error. We implemented integral saturation at 500000 to prevent integral windup, which could have caused instability and overshooting if not handled."}],"\n",["$","p",null,{"children":"The integral term was particularly helpful for consistent performance over long straight sections where small but persistent errors would otherwise accumulate after the robot had corrected for errors previously."}],"\n",["$","h3",null,{"children":"Bonus"}],"\n",["$","video",null,{"src":"/cmput412-akhadeli/images/ex3/Bonus.mp4","controls":true}],"\n",["$","p",null,{"children":"This video demonstrates our robot following the lane on the left side of the road, using the English driving system. We modified our lane detection to account for the switch in driving system, and modified the controller to handle the mirrored behavior."}],"\n",["$","h3",null,{"children":"Reflection"}],"\n",["$","p",null,{"children":"We found this exercise very insighful, as we got the opportunity to work with PID controllers, which are used in many real world applications in robotics and control systems. We additionally got to coordinate computer vision with control which is a great practical example of how computer vision can be used as feedback for a control system. Addtionally, we gained insight into autonomous navigation and the challenges that come with it, since we had to deal with similar challenges when working on lane following."}],"\n",["$","h3",null,{"children":"Code"}],"\n",["$","p",null,{"children":["Find the code using the link\n",["$","a",null,{"href":"https://github.com/akhadeli/cmput412-akhadeli-code/tree/main/exercise-3","children":"Code"}]]}],"\n",["$","h3",null,{"children":"References"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["$","a",null,{"href":"https://wiki.ros.org/ROS/Tutorials","children":"ROS Documentation"}]}],"\n",["$","li",null,{"children":["$","a",null,{"href":"https://docs.duckietown.com/daffy/devmanual-software/beginner","children":"Duckiebot Documentation"}]}],"\n",["$","li",null,{"children":["$","a",null,{"href":"https://medium.com/@nahmed3536/wheel-odometry-model-for-differential-drive-robotics-91b85a012299","children":"Odometry Medium Article"}]}],"\n",["$","li",null,{"children":["$","a",null,{"href":"https://david010.medium.com/lane-tracking-via-computer-vision-2acb4c7c1c22","children":"Lane Tracking Article"}]}],"\n",["$","li",null,{"children":["$","a",null,{"href":"https://docs.opencv.org/","children":"OpenCV Documentation"}]}],"\n",["$","li",null,{"children":["$","a",null,{"href":"https://www.geeksforgeeks.org/multiple-color-detection-in-real-time-using-python-opencv/","children":"GeeksForGeeks Article"}]}],"\n",["$","li",null,{"children":["$","a",null,{"href":"https://en.wikipedia.org/wiki/PID_controller","children":"PID Controller Wikipedia"}]}],"\n",["$","li",null,{"children":["$","a",null,{"href":"https://www.youtube.com/watch?v=y3K6FUgrgXw","children":"PID Controllers in Unity"}]}],"\n",["$","li",null,{"children":["$","a",null,{"href":"https://en.wikipedia.org/wiki/HSL_and_HSV","children":"HSV Color Space Wikipedia"}]}],"\n"]}]]}]}],[["$","link","0",{"rel":"stylesheet","href":"/cmput412-akhadeli/_next/static/css/e23141aac3fba32d.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","$L8",null,{"children":"$L9"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","h6CHAbBHIHoxEHxQMHCBN",{"children":[["$","$La",null,{"children":"$Lb"}],["$","$Lc",null,{"children":"$Ld"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$e","$undefined"],"s":false,"S":true}
d:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
b:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"CMPUT 412/503 - Abdullah Khadeli"}],["$","meta","2",{"name":"description","content":"A documentation site for CMPUT 412/503 - Abdullah Khadeli"}],["$","link","3",{"rel":"icon","href":"/cmput412-akhadeli/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
9:null
