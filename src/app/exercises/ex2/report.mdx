# CMPUT 412/503 - Exercise 2 Report

## Abdullah Khadeli and Ryan Rom

### Part I: Getting comfortable with ROS

- Node - What is a ROS node, and what is its role in the ROS ecosystem?
- Topic - What are ROS topics, and how do they facilitate communication between
  nodes?
- Service - What are ROS services, and how do they differ from topics?
- Message - What are ROS messages, and how are they structured for
  communication?
- Bag - What is a ROS bag, and how is it used in data recording and playback?
- Can you describe the typical workow for setting up communication between
  multiple nodes in ROS?

- Add a screenshot of your first publisher and subscriber nodes in action.

- Include a screenshot of the annotated image using rqt_image_view.

### Part II: Odometry using wheel encoders

#### Straight line task

- Why is there a difference between the actual and desired location?

Most of the time the bot stops near exact distance (1.25m) but sometimes it goes way over it. 
We suspect one reason for this is because of lag. 
A discrepancy of the connection between the messages that the publisher is sending to the robot. 
The robot gets the shutdown signal late which includes WheelsCMDStamped(vel_left=0, vel_right=0).

Another reason is the rate of messages publishing. 
We observed that when the rate of message publishing is too low (E.g. 3 messages per second) it is more likely to overshoot. 
This is because the interval of message sending is large which allows for larger error.

- What speed did you use?


- What happens when you increase or decrease the speed?

Increasing the speed leads to more accurate results in our case. 
This is likely because the mat used for the robot has been tampered a lot over 2 weeks as other students use it for their testing and a lot of accidental stepping on mat has happened.
Decreasing the speed leads to less accurate results like for the same reason expressed previously.

#### Rotation task

- Did you observe any deviations in the rotation?
- If deviations exist, what could be the cause?

One of the most pressing problems we faced in the rotation task is overshooting.
After spending a long time tweaking our implementation, we achieved near exact 90 degree rotation in most of our runs.
However, sometimes it overshoots and, rarely, its spins around more than 360 degrees.
It mainly came from the lag and number of published messages per second. 
There was nothing we can do about the former. For the latter, we set a tolerance threshold such that when the read that total change in angle of the robot frame is within that lower threshold we stop the robot.
As well, we increased the number of published messages per second. This makes the interval of error really small so it only overshoots a little if we ever do and there is no lag.

- Does your program exit properly after you nish all the above tasks? Is it still running
  even if you shut down the program? If this is the case, think about how to resolve this
  issue

- Plot of the rosbag results

### Part III: Playing with Duckiebots

- Clearly document the mapping of states to LED colors in your report

Red means the duckiebot is in a stopped state and Green means that the duckiebot is moving. 
When the node shuts down, we turn the lights off.

- Include plot of the rosbag results
- Print the total execution time for the task and add it in the report.
- Is your duckiebot able to track what you planned according to your plan? If not,
  then why?

  Accumulation of small errors leading to big errors in the long run (E.g. minor deviation from the first straight line task in the D path tracing leads to the robot not reaching the end position)
  It is also very hard to get accurate movement from the robot because of the reasons stated in the previous parts.
